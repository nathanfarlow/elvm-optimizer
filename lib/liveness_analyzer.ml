(* open Core *)
(* open Ast *)

(* type t = { get_living_after : Statement.t Node.t -> Variable.t Set.t } *)

(* let create () = *)
(*   let get_living_before get_living_after node = *)
(*     let living = get_living_after node in *)
(*     match Statement.get_assignment (Node.stmt node) with *)
(*     | None -> living *)
(*     | Some { from; to_ } -> *)
(*       Set.remove living from |> Set.union (Rhs.get_all_lhs_dependencies to_) *)
(*   in *)
(*   let get_living_after = *)
(*     Graph_util.memoize *)
(*       ~f:(fun node get_living_after -> *)
(*         Graph_util.get_all_branch_targets node *)
(*         |> List.map ~f:(get_living_before get_living_after) *)
(*         |> Lhs_set.union_list) *)
(*       ~on_cycle:(fun _ -> Lhs_set.empty) *)
(*   in *)
(*   { get_living_after } *)
(* ;; *)

(* let get_living_after t = t.get_living_after *)
